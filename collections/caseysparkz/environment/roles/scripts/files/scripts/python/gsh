#!/usr/bin/env python3
# Copyright (C) 2025
# Author:       Casey Sparks
# Date:         November 24, 2022
# Description:
"""A script to create PGP-encrypted scripts.

Note that decrypted scripts get passed to a bash subshell, so all
non-POSIX files **must** have a shebang in order to be properly
interpreted by bash.

To optionally encrypt the resultant script to yourself automatically:
    * Set $PGP_KEY_ID in your environment, or
    * Set default-recipient to your uid in ~/.gnupg/gpg.conf
"""

from argparse import ArgumentParser, Namespace
from datetime import datetime
from pathlib import Path

from gnupg import GPG
from psutil import process_iter


def get_arguments() -> Namespace:
    """Get cmdline arguments.

    Returns:
        argparse.Namespace instance of user arguments.
    """
    parser = ArgumentParser(description=__doc__)

    parser.add_argument("file", type=Path, nargs="+", help="Specify files to encrypt.")
    parser.add_argument(  # --recipients
        "--recipients",
        "-r",
        dest="recipients",
        nargs="+",
        default=[],
        help="Specify who can decrypt the file.",
    )
    parser.add_argument(  # --verbose
        "--verbose",
        "-v",
        dest="log_level",
        default=0,
        action="count",
        help="Specify logging verbosity. Default `CRITICAL`.",
    )

    arguments = parser.parse_args()
    arguments.log_level = range(40, -1, -10)[min(arguments.log_level, 3)]

    return arguments


def prechecks_pass(arguments: Namespace) -> bool:
    """Check that inputs and processes are as expected.

    Args:
        arguments:   User-specified cmdline arguments.

    Returns:
        Boolean indicating if prechecks have passed.
    """
    for gpg_proc in ("gpg-agent", "gpgconf"):  # Check that a GPG agent is running
        for proc in process_iter():
            if gpg_proc in proc.name():
                break  # Only one process needs to be found

        else:
            continue

        break

    for file in arguments.file:  # Check that the input files exist.
        file.resolve(strict=True)

    return True


def encrypt(file: Path, recipients: list) -> Path:
    """Decrypt seed phrase and return its value.

    Args:
        file:        The path of the file to be encrypted.
        recipients:  The recipient emails of the cipherfile.

    Returns:
        Path of the resultant cipherfile.
    """
    gpg = GPG(gpgbinary="/usr/bin/gpg2", use_agent=True, verbose=False)
    outfile = file.with_suffix("")

    with Path(file).open("rb") as infile:
        gpg.encrypt_file(
            infile,
            recipients=recipients,
            armor=True,  # Output as ASCII text
            always_trust=True,
            output=outfile,
        )

    return outfile


def munge_cipherfile(cipherfile: Path) -> None:
    """Headers and footers to cipherfile needed for shell interpretation.

    Args:
        cipherfile: The path of the file to be encrypted.
    """
    newlines = [  # GSHscript cleartext header
        "#!/usr/bin/env bash\n",
        "# Author:       Casey Sparks\n",
        f"# Date:         {datetime.now().strftime('%B %d, %Y')}\n",  # noqa: DTZ005
        "\n",
        "gpg2 --decrypt 2> /dev/null << EOF | bash -s $@\n",
        "\n",
    ]

    with Path(cipherfile).open("r", encoding="utf-8") as file:  # Read ciphertext to newlines
        newlines.extend(file.readlines())

    newlines.extend("\nEOF\n")  # Add heredoc delimiter

    with Path(cipherfile).open("w", encoding="utf-8") as file:  # Write newlines to ciphertext
        file.writelines(newlines)

    cipherfile.chmod(0o755)  # Make cipherfile executable


if __name__ == "__main__":
    args = get_arguments()

    if prechecks_pass(args):
        for clearfile in args.file:
            munge_cipherfile(encrypt(clearfile, args.recipients))
            print(f"{clearfile} encrypted.\nYou may now delete the original, if it still exists.")
